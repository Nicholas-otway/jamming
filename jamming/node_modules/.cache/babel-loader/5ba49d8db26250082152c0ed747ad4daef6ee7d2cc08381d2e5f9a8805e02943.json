{"ast":null,"code":"let accessToken = \"\";\nconst clientID = \"d6dcfa48eb5d4b40a1e37e15b909dff9\";\nconst redirectUrl = \"http://localhost:3000\";\nconst Spotify = {\n  getAccessToken() {\n    //first check for the access token\n    if (accessToken) return accessToken;\n    const urlAccessToken = window.location.href.match(/access_token=([^&]*)/);\n    const urlTokenExpiration = window.location.href.match(/expires_in=([^&]*)/);\n\n    //second check for the access token\n    if (urlAccessToken && urlTokenExpiration) {\n      //setting access token and expiry time var;\n      accessToken = urlAccessToken[1];\n      const tokenExpire = Number(urlTokenExpiration[1]);\n\n      //setting the function which will reset the access token when it  expires\n      window.setTimeout(() => accessToken = \"\", tokenExpire * 1000);\n\n      //Cleari the url after the access token is expired\n      window.history.pushState(\"Access token\", null, \"/\");\n      return accessToken;\n    }\n\n    //third check for the access token if the first and second check are both false\n    const redirect = `https://accounts.spotify.com/authorize?client_id=${clientID}&response_type=token&scope=playlist-modify-public&redirect_uri=${redirectUrl}`;\n    window.location = redirect;\n  },\n  search(term) {\n    accessToken = Spotify.getAccessToken();\n    return fetch(`https://api.spotify.com/v1/search?type=track&q=${term}`, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${accessToken}`\n      }\n    }).then(response => response.json()).then(jsonResponse => {\n      if (!jsonResponse) {\n        console.log(\"Error\");\n      }\n      console.log(accessToken);\n      return jsonResponse.tracks.items.map(trac => ({\n        id: trac.id,\n        name: trac.name,\n        artist: trac.artists[0].name,\n        album: trac.album.name,\n        uri: trac.uri\n      }));\n    });\n  },\n  savePlaylist(name, trackarr) {\n    if (!name || !trackarr) return;\n    const secondAccessToken = Spotify.getAccessToken;\n    const header = {\n      Authorization: `Bearer ${secondAccessToken}`\n    };\n    const userId = \"\";\n    return fetch(`https://api.spotify.com/v1/me`, {\n      headers: header\n    }).then(response => response.json()).then(jsonResponse => {\n      userId = jsonResponse.id;\n      return fetch(`https://api.spotify.com/v1/users/${userId}/playlists`, {\n        headers: header,\n        method: \"post\",\n        body: JSON.stringify({\n          name: name\n        })\n      });\n    });\n  }\n};\nexport { Spotify };\n\n/*let accessToken = \"\";\nconst clientID = \"16d9887644e0457db5532ebebd476d30\";\n const redirectUrl = \"http://localhost:3000\";\n//const redirectUrl = \"https://syphersjammmingproject.surge.sh\";\n\nconst Spotify = {\n  getAccessToken() {\n    // First check for the access token\n    if (accessToken) return accessToken;\n\n    const tokenInURL = window.location.href.match(/access_token=([^&]*)/);\n    const expiryTime = window.location.href.match(/expires_in=([^&]*)/);\n\n    // Second check for the access token\n    if (tokenInURL && expiryTime) {\n      // setting access token and expiry time variables\n      accessToken = tokenInURL[1];\n      const expiresIn = Number(expiryTime[1]);\n\n      // Setting the access token to expire at the value for expiration time\n      window.setTimeout(() => (accessToken = \"\"), expiresIn * 1000);\n      // clearing the url after the access token expires\n      window.history.pushState(\"Access token\", null, \"/\");\n      return accessToken;\n    }\n\n    // Third check for the access token if the first and second check are both false\n    const redirect = `https://accounts.spotify.com/authorize?client_id=${clientID}&response_type=token&scope=playlist-modify-public&redirect_uri=${redirectUrl}`;\n    window.location = redirect;\n  },\n\n  search(term) {\n    accessToken = Spotify.getAccessToken();\n    return fetch(`https://api.spotify.com/v1/search?type=track&q=${term}`, {\n      method: \"GET\",\n      headers: { Authorization: `Bearer ${accessToken}` },\n    })\n      .then((response) => response.json())\n      .then((jsonResponse) => {\n        if (!jsonResponse) {\n          console.error(\"Response error\");\n        }\n        return jsonResponse.tracks.items.map((t) => ({\n          id: t.id,\n          name: t.name,\n          artist: t.artists[0].name,\n          album: t.album.name,\n          uri: t.uri,\n        }));\n      });\n  },\n};\nexport { Spotify };*/","map":{"version":3,"names":["accessToken","clientID","redirectUrl","Spotify","getAccessToken","urlAccessToken","window","location","href","match","urlTokenExpiration","tokenExpire","Number","setTimeout","history","pushState","redirect","search","term","fetch","method","headers","Authorization","then","response","json","jsonResponse","console","log","tracks","items","map","trac","id","name","artist","artists","album","uri","savePlaylist","trackarr","secondAccessToken","header","userId","body","JSON","stringify"],"sources":["/Users/grimotway/Documents/ReactJammingProject/jamming/src/util/Spotify/Spotify.js"],"sourcesContent":["let accessToken = \"\";\nconst clientID = \"d6dcfa48eb5d4b40a1e37e15b909dff9\";\nconst redirectUrl = \"http://localhost:3000\";\n\nconst Spotify = {\n  getAccessToken() {\n    //first check for the access token\n    if (accessToken) return accessToken;\n\n    const urlAccessToken = window.location.href.match(/access_token=([^&]*)/);\n    const urlTokenExpiration = window.location.href.match(/expires_in=([^&]*)/);\n\n    //second check for the access token\n    if (urlAccessToken && urlTokenExpiration) {\n      //setting access token and expiry time var;\n      accessToken = urlAccessToken[1];\n      const tokenExpire = Number(urlTokenExpiration[1]);\n\n      //setting the function which will reset the access token when it  expires\n      window.setTimeout(() => (accessToken = \"\"), tokenExpire * 1000);\n\n      //Cleari the url after the access token is expired\n      window.history.pushState(\"Access token\", null, \"/\");\n      return accessToken;\n    }\n\n    //third check for the access token if the first and second check are both false\n    const redirect = `https://accounts.spotify.com/authorize?client_id=${clientID}&response_type=token&scope=playlist-modify-public&redirect_uri=${redirectUrl}`;\n    window.location = redirect;\n  },\n\n  search(term) {\n    accessToken = Spotify.getAccessToken();\n    return fetch(`https://api.spotify.com/v1/search?type=track&q=${term}`, {\n      method: \"GET\",\n      headers: { Authorization: `Bearer ${accessToken}` },\n    })\n      .then((response) => response.json())\n      .then((jsonResponse) => {\n        if (!jsonResponse) {\n          console.log(\"Error\");\n        }\n        console.log(accessToken);\n        return jsonResponse.tracks.items.map((trac) => ({\n          id: trac.id,\n          name: trac.name,\n          artist: trac.artists[0].name,\n          album: trac.album.name,\n          uri: trac.uri,\n        }));\n      });\n  },\n\n  savePlaylist(name, trackarr) {\n    if (!name || !trackarr) return;\n    const secondAccessToken = Spotify.getAccessToken;\n    const header = { Authorization: `Bearer ${secondAccessToken}` };\n    const userId = \"\";\n    return fetch(`https://api.spotify.com/v1/me`, { headers: header })\n      .then((response) => response.json())\n      .then((jsonResponse) => {\n        userId = jsonResponse.id;\n\n\n    return fetch(`https://api.spotify.com/v1/users/${userId}/playlists`, {\n        headers: header,\n        method: \"post\",\n        body: JSON.stringify({ name: name })\n      })\n    });\n  }\n};\n\nexport { Spotify };\n\n/*let accessToken = \"\";\nconst clientID = \"16d9887644e0457db5532ebebd476d30\";\n const redirectUrl = \"http://localhost:3000\";\n//const redirectUrl = \"https://syphersjammmingproject.surge.sh\";\n\nconst Spotify = {\n  getAccessToken() {\n    // First check for the access token\n    if (accessToken) return accessToken;\n\n    const tokenInURL = window.location.href.match(/access_token=([^&]*)/);\n    const expiryTime = window.location.href.match(/expires_in=([^&]*)/);\n\n    // Second check for the access token\n    if (tokenInURL && expiryTime) {\n      // setting access token and expiry time variables\n      accessToken = tokenInURL[1];\n      const expiresIn = Number(expiryTime[1]);\n\n      // Setting the access token to expire at the value for expiration time\n      window.setTimeout(() => (accessToken = \"\"), expiresIn * 1000);\n      // clearing the url after the access token expires\n      window.history.pushState(\"Access token\", null, \"/\");\n      return accessToken;\n    }\n\n    // Third check for the access token if the first and second check are both false\n    const redirect = `https://accounts.spotify.com/authorize?client_id=${clientID}&response_type=token&scope=playlist-modify-public&redirect_uri=${redirectUrl}`;\n    window.location = redirect;\n  },\n\n  search(term) {\n    accessToken = Spotify.getAccessToken();\n    return fetch(`https://api.spotify.com/v1/search?type=track&q=${term}`, {\n      method: \"GET\",\n      headers: { Authorization: `Bearer ${accessToken}` },\n    })\n      .then((response) => response.json())\n      .then((jsonResponse) => {\n        if (!jsonResponse) {\n          console.error(\"Response error\");\n        }\n        return jsonResponse.tracks.items.map((t) => ({\n          id: t.id,\n          name: t.name,\n          artist: t.artists[0].name,\n          album: t.album.name,\n          uri: t.uri,\n        }));\n      });\n  },\n};\nexport { Spotify };*/\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}